diff --git a/st/arg.h b/st/arg.h
index a22e019..9fa9a4c 100644
--- a/st/arg.h
+++ b/st/arg.h
@@ -12,19 +12,19 @@ extern char *argv0;
 #define ARGBEGIN	for (argv0 = *argv, argv++, argc--;\
 					argv[0] && argv[0][0] == '-'\
 					&& argv[0][1];\
-					argc--, argv++) {\
+					--argc, ++argv) {\
 				char argc_;\
 				char **argv_;\
 				int brk_;\
 				if (argv[0][1] == '-' && argv[0][2] == '\0') {\
-					argv++;\
-					argc--;\
+					++argv;\
+					--argc;\
 					break;\
 				}\
 				int i_;\
 				for (i_ = 1, brk_ = 0, argv_ = argv;\
 						argv[0][i_] && !brk_;\
-						i_++) {\
+						++i_) {\
 					if (argv_ != argv)\
 						break;\
 					argc_ = argv[0][i_];\
diff --git a/st/st.c b/st/st.c
index 3a68d05..916baea 100644
--- a/st/st.c
+++ b/st/st.c
@@ -451,7 +451,7 @@ tlinelen(Line line)
 {
 	int i = term.col - 1;
 
-	for (; i >= 0 && !(line[i].mode & (ATTR_SET | ATTR_WRAP)); i--);
+	for (; i >= 0 && !(line[i].mode & (ATTR_SET | ATTR_WRAP)); --i);
 	return i + 1;
 }
 
@@ -468,7 +468,7 @@ tgetglyphs(char *buf, const Glyph *gp, const Glyph *lgp)
 {
 	while (gp <= lgp)
 		if (gp->mode & ATTR_WDUMMY) {
-			gp++;
+			++gp;
 		} else {
 			buf += utf8encode((gp++)->u, buf);
 		}
@@ -482,7 +482,7 @@ tgetline(char *buf, const Glyph *fgp)
 	const Glyph *lgp = &fgp[term.col - 1];
 
 	while (lgp > fgp && !(lgp->mode & (ATTR_SET | ATTR_WRAP)))
-		lgp--;
+		--lgp;
 	ptr = tgetglyphs(buf, fgp, lgp);
 	if (!(lgp->mode & ATTR_WRAP))
 		*(ptr++) = '\n';
@@ -670,7 +670,7 @@ getsel(void)
 	ptr = str;
 
 	/* append every set & selected glyph to the selection */
-	for (y = sel.nb.y; y <= sel.ne.y; y++) {
+	for (y = sel.nb.y; y <= sel.ne.y; ++y) {
 		Line line = TLINE(y);
 
 		if ((linelen = tlinelen(line)) == 0) {
@@ -1026,8 +1026,8 @@ tattrset(int attr)
 {
 	int i, j;
 
-	for (i = 0; i < term.row-1; i++) {
-		for (j = 0; j < term.col-1; j++) {
+	for (i = 0; i < term.row-1; ++i) {
+		for (j = 0; j < term.col-1; ++j) {
 			if (term.line[i][j].mode & attr)
 				return 1;
 		}
@@ -1044,7 +1044,7 @@ tsetdirt(int top, int bot)
 	LIMIT(top, 0, term.row-1);
 	LIMIT(bot, 0, term.row-1);
 
-	for (i = top; i <= bot; i++)
+	for (i = top; i <= bot; ++i)
 		term.dirty[i] = 1;
 }
 
@@ -1053,8 +1053,8 @@ tsetdirtattr(int attr)
 {
 	int i, j;
 
-	for (i = 0; i < term.row-1; i++) {
-		for (j = 0; j < term.col-1; j++) {
+	for (i = 0; i < term.row-1; ++i) {
+		for (j = 0; j < term.col-1; ++j) {
 			if (term.line[i][j].mode & attr) {
 				term.dirty[i] = 1;
 				break;
@@ -1066,7 +1066,7 @@ tsetdirtattr(int attr)
 void
 tfulldirt(void)
 {
-  for (int i = 0; i < term.row; i++)
+  for (int i = 0; i < term.row; ++i)
 		term.dirty[i] = 1;
 }
 
@@ -1111,10 +1111,10 @@ treset(void)
 	term.charset = 0;
 
   selremove();
-	for (i = 0; i < 2; i++) {
+	for (i = 0; i < 2; ++i) {
   	tcursor(CURSOR_SAVE); /* reset saved cursor */
-		for (y = 0; y < term.row; y++)
-			for (x = 0; x < term.col; x++)
+		for (y = 0; y < term.row; ++y)
+			for (x = 0; x < term.col; ++x)
 				tclearglyph(&term.line[y][x], 0);
 		tswapscreen();
 	}
@@ -1126,16 +1126,16 @@ tnew(int col, int row)
 {
 	int i, j;
 
-	for (i = 0; i < 2; i++) {
+	for (i = 0; i < 2; ++i) {
 		term.line = xmalloc(row * sizeof(Line));
-		for (j = 0; j < row; j++)
+		for (j = 0; j < row; ++j)
 			term.line[j] = xmalloc(col * sizeof(Glyph));
 		term.col = col, term.row = row;
 		tswapscreen();
 	}
 	term.dirty = xmalloc(row * sizeof(*term.dirty));
 	term.tabs = xmalloc(col * sizeof(*term.tabs));
-	for (i = 0; i < HISTSIZE; i++)
+	for (i = 0; i < HISTSIZE; ++i)
 		term.hist[i] = xmalloc(col * sizeof(Glyph));
   treset();
 }
@@ -1255,7 +1255,7 @@ tscrolldown(int top, int n)
 	tsetdirt(top, bot-n);
 	tclearregion(0, bot-n+1, term.col-1, bot, 1);
 
-	for (i = bot; i >= top+n; i--) {
+	for (i = bot; i >= top+n; --i) {
 		temp = term.line[i];
 		term.line[i] = term.line[i-n];
 		term.line[i-n] = temp;
@@ -1278,10 +1278,10 @@ tscrollup(int top, int bot, int n, int mode)
 	n = MIN(n, bot-top+1);
 
 	if (savehist) {
-		for (i = 0; i < n; i++) {
+		for (i = 0; i < n; ++i) {
 			term.histi = (term.histi + 1) % HISTSIZE;
 			temp = term.hist[term.histi];
-			for (j = 0; j < term.col; j++)
+			for (j = 0; j < term.col; ++j)
 				tclearglyph(&temp[j], 1);
 			term.hist[term.histi] = term.line[i];
 			term.line[i] = temp;
@@ -1300,7 +1300,7 @@ tscrollup(int top, int bot, int n, int mode)
 		tsetdirt(top+n, bot);
 	}
 
-	for (i = top; i <= bot-n; i++) {
+	for (i = top; i <= bot-n; ++i) {
 		temp = term.line[i];
 		term.line[i] = term.line[i+n];
 		term.line[i+n] = temp;
@@ -1466,9 +1466,9 @@ tclearregion(int x1, int y1, int x2, int y2, int usecurattr)
 	if (regionselected(x1+term.scr, y1+term.scr, x2+term.scr, y2+term.scr))
 		selremove();
 
-	for (y = y1; y <= y2; y++) {
+	for (y = y1; y <= y2; ++y) {
 		term.dirty[y] = 1;
-		for (x = x1; x <= x2; x++)
+		for (x = x1; x <= x2; ++x)
 			tclearglyph(&term.line[y][x], usecurattr);
 	}
 }
@@ -1580,7 +1580,7 @@ tsetattr(const int *attr, int l)
 	int i;
 	int32_t idx;
 
-	for (i = 0; i < l; i++) {
+	for (i = 0; i < l; ++i) {
 		switch (attr[i]) {
 		case 0:
 			term.c.attr.mode &= ~(
@@ -1936,7 +1936,7 @@ csihandle(void)
 			tscrollup(0, term.row-1, term.row, SCROLL_SAVEHIST); */
       
 			/* alacritty does this: */
-			for (n = term.row-1; n >= 0 && tlinelen(term.line[n]) == 0; n--);
+			for (n = term.row-1; n >= 0 && tlinelen(term.line[n]) == 0; --n);
 			if (n >= 0)
 				tscrollup(0, term.row-1, n+1, SCROLL_SAVEHIST);
 			tscrollup(0, term.row-1, term.row-n-1, SCROLL_NOSAVEHIST);
@@ -2046,7 +2046,7 @@ csidump(void)
 	uint c;
 
 	fprintf(stderr, "ESC[");
-	for (i = 0; i < csiescseq.len; i++) {
+	for (i = 0; i < csiescseq.len; ++i) {
 		c = csiescseq.buf[i] & 0xff;
 		if (isprint(c)) {
 			putc(c, stderr);
@@ -2222,7 +2222,7 @@ strdump(void)
 	uint c;
 
 	fprintf(stderr, "ESC%c", strescseq.type);
-	for (i = 0; i < strescseq.len; i++) {
+	for (i = 0; i < strescseq.len; ++i) {
 		c = strescseq.buf[i] & 0xff;
 		if (c == '\0') {
 			putc('\n', stderr);
@@ -2319,7 +2319,7 @@ tputtab(int n)
 	uint x = term.c.x;
 
 	if (n > 0) {
-		while (x < term.col && n--)
+		while (x < term.col && n++)
 			for (++x; x < term.col && !term.tabs[x]; ++x)
 				/* nothing */ ;
 	} else if (n < 0) {
@@ -2760,7 +2760,7 @@ treflow(int col, int row)
 
 	/* y coordinate of cursor line end */
 	for (oce = term.c.y; oce < term.row - 1 &&
-	                     tiswrapped(term.line[oce]); oce++);
+	                     tiswrapped(term.line[oce]); ++oce);
 
 	nlines = term.histf + oce + 1;
 	if (col < term.col) {
@@ -2794,7 +2794,7 @@ treflow(int col, int row)
 			memcpy(&buf[ny][nx], &line[ox], (len-ox) * sizeof(Glyph));
 			nx += len - ox;
 			if (len == 0 || !(line[len - 1].mode & ATTR_WRAP)) {
-				for (j = nx; j < col; j++)
+				for (j = nx; j < col; ++j)
 					tclearglyph(&buf[ny][j], 0);
 				nx = 0;
 			} else if (nx > 0) {
@@ -2812,11 +2812,11 @@ treflow(int col, int row)
 		}
 	} while (oy <= oce);
 	if (nx)
-		for (j = nx; j < col; j++)
+		for (j = nx; j < col; ++j)
 			tclearglyph(&buf[ny][j], 0);
 
 	/* free extra lines */
-	for (i = row; i < term.row; i++)
+	for (i = row; i < term.row; ++i)
 		free(term.line[i]);
 	/* resize to new height */
 	term.line = xrealloc(term.line, row * sizeof(Line));
@@ -2836,20 +2836,20 @@ treflow(int col, int row)
 		}
 	}
 	/* allocate new rows */
-	for (i = row - 1; i > nce; i--) {
+	for (i = row - 1; i > nce; --i) {
 		term.line[i] = xmalloc(col * sizeof(Glyph));
-		for (j = 0; j < col; j++)
+		for (j = 0; j < col; ++j)
 			tclearglyph(&term.line[i][j], 0);
 	}
 	/* fill visible area */
-	for (/*i = nce */; i >= term.row; i--, ny--)
+	for (/*i = nce */; i >= term.row; --i, --ny)
 		term.line[i] = buf[ny];
-	for (/*i = term.row - 1 */; i >= 0; i--, ny--) {
+	for (/*i = term.row - 1 */; i >= 0; --i, --ny) {
 		free(term.line[i]);
 		term.line[i] = buf[ny];
 	}
 	/* fill lines in history buffer and update term.histf */
-	for (/*i = -1 */; ny >= 0 && i >= -HISTSIZE; i--, ny--) {
+	for (/*i = -1 */; ny >= 0 && i >= -HISTSIZE; --i, --ny) {
 		j = (term.histi + i + 1 + HISTSIZE) % HISTSIZE;
 		free(term.hist[j]);
 		term.hist[j] = buf[ny];
@@ -2857,7 +2857,7 @@ treflow(int col, int row)
 	term.histf = -i - 1;
 	term.scr = MIN(term.scr, term.histf);
 	/* resize rest of the history lines */
-	for (/*i = -term.histf - 1 */; i >= -HISTSIZE; i--) {
+	for (/*i = -term.histf - 1 */; i >= -HISTSIZE; --i) {
 		j = (term.histi + i + 1 + HISTSIZE) % HISTSIZE;
 		term.hist[j] = xrealloc(term.hist[j], col * sizeof(Glyph));
 	}
@@ -2877,12 +2877,12 @@ rscrolldown(int n)
 	if ((n = MIN(n, term.histf)) <= 0)
 		return;
 
-	for (i = term.c.y + n; i >= n; i--) {
+	for (i = term.c.y + n; i >= n; --i) {
 		temp = term.line[i];
 		term.line[i] = term.line[i-n];
 		term.line[i-n] = temp;
 	}
-	for (/*i = n - 1 */; i >= 0; i--) {
+	for (/*i = n - 1 */; i >= 0; --i) {
 		temp = term.line[i];
 		term.line[i] = term.hist[term.histi];
 		term.hist[term.histi] = temp;
@@ -2947,15 +2947,15 @@ tresizedef(int col, int row)
 			tscrollup(0, term.row - 1, term.c.y - row + 1, SCROLL_RESIZE);
 			term.c.y = row - 1;
 		}
-		for (i = row; i < term.row; i++)
+		for (i = row; i < term.row; ++i)
 			free(term.line[i]);
 
 		/* resize to new height */
 		term.line = xrealloc(term.line, row * sizeof(Line));
 		/* allocate any new rows */
-		for (i = term.row; i < row; i++) {
+		for (i = term.row; i < row; ++i) {
 			term.line[i] = xmalloc(col * sizeof(Glyph));
-			for (j = 0; j < col; j++)
+			for (j = 0; j < col; ++j)
 				tclearglyph(&term.line[i][j], 0);
 		}
 		/* scroll down as much as height has increased */
@@ -2982,27 +2982,27 @@ tresizealt(int col, int row)
 	if (sel.alt)
 		selremove();
 	/* slide screen up if otherwise cursor would get out of the screen */
-	for (i = 0; i <= term.c.y - row; i++)
+	for (i = 0; i <= term.c.y - row; ++i)
 		free(term.line[i]);
 	if (i > 0) {
 		/* ensure that both src and dst are not NULL */
 		memmove(term.line, term.line + i, row * sizeof(Line));
 		term.c.y = row - 1;
 	}
-	for (i += row; i < term.row; i++)
+	for (i += row; i < term.row; ++i)
 		free(term.line[i]);
 	/* resize to new height */
 	term.line = xrealloc(term.line, row * sizeof(Line));
 	/* resize to new width */
-	for (i = 0; i < MIN(row, term.row); i++) {
+	for (i = 0; i < MIN(row, term.row); ++i) {
 		term.line[i] = xrealloc(term.line[i], col * sizeof(Glyph));
-		for (j = term.col; j < col; j++)
+		for (j = term.col; j < col; ++j)
 			tclearglyph(&term.line[i][j], 0);
 	}
 	/* allocate any new rows */
-	for (/*i = MIN(row, term.row) */; i < row; i++) {
+	for (/*i = MIN(row, term.row) */; i < row; ++i) {
 		term.line[i] = xmalloc(col * sizeof(Glyph));
-		for (j = 0; j < col; j++)
+		for (j = 0; j < col; ++j)
 			tclearglyph(&term.line[i][j], 0);
 	}
 	/* update cursor */
@@ -3031,7 +3031,7 @@ drawregion(int x1, int y1, int x2, int y2)
 {
 	int y;
 
-	for (y = y1; y < y2; y++) {
+	for (y = y1; y < y2; ++y) {
 		if (!term.dirty[y])
 			continue;
 
@@ -3052,9 +3052,9 @@ draw(void)
 	LIMIT(term.ocx, 0, term.col-1);
 	LIMIT(term.ocy, 0, term.row-1);
 	if (term.line[term.ocy][term.ocx].mode & ATTR_WDUMMY)
-		term.ocx--;
+		--term.ocx;
 	if (term.line[term.c.y][cx].mode & ATTR_WDUMMY)
-		cx--;
+		--cx;
 
 	drawregion(0, 0, term.col, term.row);
 	xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
diff --git a/st/x.c b/st/x.c
index aa09997..da38080 100644
--- a/st/x.c
+++ b/st/x.c
@@ -452,7 +452,7 @@ mouseaction(XEvent *e, uint release)
 	/* ignore Button<N>mask for Button<N> - it's set on release */
 	uint state = e->xbutton.state & ~buttonmask(e->xbutton.button);
 
-	for (ms = mshortcuts; ms < mshortcuts + LEN(mshortcuts); ms++) {
+	for (ms = mshortcuts; ms < mshortcuts + LEN(mshortcuts); ++ms) {
 		if (ms->release == release &&
 		    ms->button == e->xbutton.button &&
 		    (match(ms->mod, state) ||  /* exact or forced */
@@ -805,7 +805,7 @@ xloadcols(void)
 		dc.col = xmalloc(dc.collen * sizeof(Color));
 	}
 
-	for (i = 0; i < dc.collen; i++)
+	for (i = 0; i < dc.collen; ++i)
 		if (!xloadcolor(i, NULL, &dc.col[i])) {
 			if (colorname[i])
 				die("could not allocate color '%s'\n", colorname[i]);
@@ -1296,7 +1296,7 @@ xmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x
 		}
 
 		/* Fallback on font cache, search the font cache for match. */
-		for (f = 0; f < frclen; f++) {
+		for (f = 0; f < frclen; ++f) {
 			glyphidx = XftCharIndex(xw.dpy, frc[f].font, rune);
 			/* Everything correct. */
 			if (glyphidx && frc[f].flags == frcflags)
@@ -1654,7 +1654,7 @@ xdrawline(Line line, int x1, int y1, int x2)
 
 	numspecs = xmakeglyphfontspecs(specs, &line[x1], x2 - x1, x1, y1);
 	i = ox = 0;
-	for (x = x1; x < x2 && i < numspecs; x++) {
+	for (x = x1; x < x2 && i < numspecs; ++x) {
 		new = line[x];
 		if (new.mode == ATTR_WDUMMY)
 			continue;
@@ -1670,7 +1670,7 @@ xdrawline(Line line, int x1, int y1, int x2)
 			ox = x;
 			base = new;
 		}
-		i++;
+		++i;
 	}
 	if (i > 0)
 		xdrawglyphfontspecs(specs, base, i, ox, y1);
@@ -1799,7 +1799,7 @@ kmap(KeySym k, uint state)
 	int i;
 
 	/* Check for mapped keys out of X11 function keys. */
-	for (i = 0; i < LEN(mappedkeys); i++) {
+	for (i = 0; i < LEN(mappedkeys); ++i) {
 		if (mappedkeys[i] == k)
 			break;
 	}
@@ -1808,7 +1808,7 @@ kmap(KeySym k, uint state)
 			return NULL;
 	}
 
-	for (kp = key; kp < key + LEN(key); kp++) {
+	for (kp = key; kp < key + LEN(key); ++kp) {
 		if (kp->k != k)
 			continue;
 
@@ -1851,7 +1851,7 @@ kpress(XEvent *ev)
 		len = XLookupString(e, buf, sizeof buf, &ksym, NULL);
 	}
 	/* 1. shortcuts */
-	for (bp = shortcuts; bp < shortcuts + LEN(shortcuts); bp++) {
+	for (bp = shortcuts; bp < shortcuts + LEN(shortcuts); ++bp) {
 		if (ksym == bp->keysym && match(bp->mod, e->state)) {
 			bp->func(&(bp->arg));
 			return;
